module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    output spi_miso,        // AVR SPI MISO
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    output avr_rx,          // AVR RX (FPGA TX)
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]    // DIP switches on IO Shield
    ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;

    .rst(rst){
      dff store_a[16];      //delay flip flops used for storing values of a,b,alufn
      dff store_b[16];
      dff store_alufn[6];
      dff counter[29];      //counter to time the switching of states

      fsm state = {START, CASEADD, CASESUBTRACT1, CASESUBTRACT2, CASEOVERFLOW1, CASEOVERFLOW2, CASEAND,
                   CASEOR, CASEXOR, CASEA, CASESHL, CASESHR, CASESRA,
                   CASECMPEQT, CASECMPEQF, CASECMPLTT, CASECMPLTF,
                   CASECMPLET1, CASECMPLEF, CASECMPLET2, CASEMUL1, END, MANUAL};
      multi_seven_seg seg;  //using module multi_seven_seg
    }
  }
  
  sig a[16];
  sig b[16];
  sig alufn[6];
  sig out[16];
   
  alu alu1;               //creating instance of alu
  const TIMER = 28;         //constant for clock to switch states
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    io_led = 3x{{8h00}};    // turn LEDs off
    seg.values = {5d2,5d13,5d31,5d31}; //initialising values of seven segment display
    io_seg = ~seg.seg;
    io_sel = ~seg.sel;

    a = 8h0;                //initial a
    b = 8h0;                //initial b
    alufn = io_dip[0][7:2]; //setting dip switches as alufn input
    alu1.alufn = alufn;   //setting alufn
    alu1.a = a;           //setting alu a
    alu1.b = b;           //setting alu b
    out = alu1.alu;       //getting alu output
    io_led[2:1] = c{{out[15:8]},{out[7:0]}};                                 
    io_led[0][7:5] = c{alu1.z, alu1.v, alu1.n};       

    case (state.q){
      state.START:
        if(io_button[1] == 1){      //auto testing when center button is pressed
           state.d = state.CASEADD;}
        if(io_dip[0][0]){           //manual testing when last io_dip is pushed up
            state.d = state.MANUAL;}
    
      state.MANUAL:                   //manual test state
        if(io_dip[0][1]){             //if switch[0][1] is high, switch[1] and switch[2] become inputs for a
          a[7:0] = io_dip[1];
          a[15:8] = io_dip[2];
          if(io_button[1]){           //if button is pressed, store input a into a d flip flop
            store_a.d = a;
          }
        } 
        else {                        //if switch[0][1] is low, switch[1] and switch[2] become inputs for b
          b[7:0] = io_dip[1];
          b[15:8] = io_dip[2];
          if(io_button[1]){           //if button is pressed, store input b into a d flip flop
            store_b.d = b;
          }
        }
        alufn = io_dip[0][7:2];       //assigning dip switches to alufn input
        if(io_button[4]){             //if button is pressed, store input alufn into a d flip flip
          store_alufn.d = alufn;}                  
        if(io_button[4]){             //if button is pressed, reset a,b,alufn
          store_a.d = 16b0;
          store_b.d = 16b0;
          store_alufn.d = 6b0;}
        alu1.a = store_a.q;         //input stored value of a into module alu
        alu1.b = store_b.q;         //input stored value of b into module alu
        alu1.alufn = store_alufn.q; //input stored value of alufn into module alu
        io_led[0][0] = 1;
        if(io_button[2]){             //if button is pressed, return to initial state
          state.d = state.START;}

      //test case for adder
      //21930 + 8360 = 30190
      state.CASEADD:	
        alu1.alufn = 6b0;             //alufn for ADD
        alu1.a = 16b0000000000001000; //test input a
        alu1.b = 16b0000000000000000; //test input b
        if(io_dip[2][7]){             //making output invalid when first io_dip is pushed up
          out = out + b1;}
        if(out == 16b0000000000001000){   //check error                                   
          seg.values = {5d10, 5d13, 5d13, 5d31};}
        else{                             //display error on seven segment display
          seg.values = {5d14,5d2,5d2,5d31};}
        if(io_dip[0][0]){                 //manual testing when last io_dip is pushed up
          state.d = state.MANUAL;}
        counter.d = counter.q+1;                    //increment counter (clock)for every code loop
        if(io_button[4] | counter.q[TIMER]==1){     //right io_button is pressed or clock timer reaches TIMER
          counter.d = 0;
          state.d = state.CASESUBTRACT1;}

      //test case for subtractor
      //17 - 8 = 9
      state.CASESUBTRACT1:
        alu1.alufn = 6b1;
        alu1.a = 16b0000000000010001;	
        alu1.b = 16b0000000000001000;	
        seg.values = {5d5,5d3,5d11,5d1};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){     //left io_button is pressed, alternate left and right for debouncing
          counter.d = 0;
          state.d = state.CASESUBTRACT2;}

      //test case for subtractor
      // -5 - (8) = -13
      state.CASESUBTRACT2:
        alu1.alufn = 6b1;		
        alu1.a = 16b1111111111111011;
        alu1.b = 16b0000000000001000;
        seg.values = {5d5,5d3,5d11,5d22};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEOVERFLOW1;}

      //test case for overflow (add)
      //16384 + 16384 = -32768
      state.CASEOVERFLOW1:
        alu1.alufn = 6b0;		
        alu1.a = 16b0100000000000000;	
        alu1.b = 16b0100000000000000;	
        seg.values = {5d0,5d15,5d4,5d1};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEOVERFLOW2;}

      //test case for overflow (subtract)
      //24576 - (-16384) = -24576
      state.CASEOVERFLOW2:
        alu1.alufn = 6b1;		
        alu1.a = 16b0110000000000000;
        alu1.b = 16b1100000000000000;	
        seg.values = {5d0,5d15,5d4,5d22};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEAND;}

      //test case for AND boolean operation
      state.CASEAND:
        alu1.alufn = 6b011000;		//subtraction operation of ALU
        alu1.a = 16b0110100001010111;	//input a
        alu1.b = 16b1010110000001000;	//input b
        if(io_dip[2][7]){
          out = out + b1;}
        if (out == 16b0010100000000000){
            seg.values = {5d10,5d16,5d13,5d8};}
        else {
            seg.values = {5d14,5d2,5d2,5d31};}
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEOR;}

      //test case for OR boolean operation
      state.CASEOR:
        alu1.alufn = 6b011110;		//subtraction operation of ALU
        alu1.a = 16b0110100001010111;	//input a
        alu1.b = 16b1010110000001000;	//input b
        seg.values = {5d0,5d2,5d31,5d31};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEXOR;}
          
      //test case for XOR boolean operation     
      state.CASEXOR:
        alu1.alufn = 6b010110;		//subtraction operation of ALU
        alu1.a = 16b0110100001010111;	//input a
        alu1.b = 16b1010110000001000;	//input b
        seg.values = {5d17,5d0,5d2,5d31};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEA;}
    
      //test case for "A" boolean operation
      state.CASEA:
        alu1.alufn = 6b011010;		//subtraction operation of ALU
        alu1.a = 16b0110100001010111;	//input a
        alu1.b = 16b1010110000001000;	//input b
        seg.values = {5d10,5d31,5d31,5d31};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASESHL;}
          
      //test case for shift left
      state.CASESHL:
        alu1.alufn = 6b100000;		//subtraction operation of ALU
        alu1.a = 16b0100100001101100;	//input a
        alu1.b = 16b0000000000000100;	//input b
        if(io_dip[2][7]){
         out = out + b1;}
        if(out == 16b1000011011000000){
          seg.values = {5d5,5d17,5d4,5d8};}
        else{
          seg.values = {5d14,5d2,5d2,5d31};}
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASESHR;}

      //test case for shift right      
      state.CASESHR:
        alu1.alufn = 6b100001;		//subtraction operation of ALU
        alu1.a = 16b0110110011110000;	//input a
        alu1.b = 16b0000000000000110;	//input b
        seg.values = {5d5,5d17,5d2,5d31};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASESRA;}

      //test case for arithmetic shift right
      state.CASESRA:
        alu1.alufn = 6b100011;		//subtraction operation of ALU
        alu1.a = 16b1100100001100001;	//input a
        alu1.b = 16b0000000000001100;	//input b
        seg.values = {5d5,5d2,5d10,5d31};
        if(io_dip[0][0]){
           state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPEQT;}
    
      //test case for comparing a==b
      //output = true
      state.CASECMPEQT:
        alu1.alufn = 6b110011;		//compare equals to (True)
        alu1.a = 16b0000000000000101;	//input a
        alu1.b = 16b0000000000000101;	//input b
        if(io_dip[2][7]){
          out = out + b1;}
        if(out == 16b0000000000000001){
          seg.values = {5d12,5d6,5d14,5d1};}
        else{
          seg.values = {5d14,5d2,5d2,5d31};}
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPEQF;}

      //test case for comparing a==b
      //output = false
        state.CASECMPEQF:
        alu1.alufn = 6b110011;		//compare equals to
        alu1.a = 16b0000000000000101;	//input a
        alu1.b = 16b0000000000000100;	//input b
        seg.values = {5d12,5d6,5d14,5d22};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPLTT;}
          
      //test case for comparing a<b
      //output = true
      state.CASECMPLTT:
        alu1.alufn = 6b110101;		//compare equals to
        alu1.a = 16b0000000000000010;	//input a
        alu1.b = 16b0000000000000011;	//input b
        seg.values = {5d12,5d6,5d4,5d1};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPLTF;}
    
      //test case for comparing a<b
      //output = false
      state.CASECMPLTF:
        alu1.alufn = 6b110101;		//compare equals to
        alu1.a = 16b0000000000000110;	//input a
        alu1.b = 16b1111111111111011;	//input b
        seg.values = {5d12,5d6,5d4,5d22};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPLET1;}

      //test case for comparing a<=b
      //output = true
      state.CASECMPLET1:
        alu1.alufn = 6b110111;		//compare equals to
        alu1.a = 16b1111111111111100;	//input a
        alu1.b = 16b0000000000000111;	//input b
        seg.values = {5d12,5d4,5d14,5d1};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPLEF;}
             
      //test case for comparing a<=b
      //output = false
      state.CASECMPLEF:
        alu1.alufn = 6b110111;		//compare equals to
        alu1.a = 16b0000000000000110;	//input a
        alu1.b = 16b0000000000000011;	//input b
        seg.values = {5d12,5d4,5d14,5d22};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASECMPLET2;}
    
      //test case for comparing a<=b
      //output = true
      state.CASECMPLET2:
        alu1.alufn = 6b110111;		//compare equals to
        alu1.a = 16b0000000000000101;	//input a
        alu1.b = 16b0000000000000101;	//input b
        seg.values = {5d12,5d4,5d14,5d30};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[4] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.CASEMUL1;}
      
      //test case for multiply
      // 3 * 2 = 6
      state.CASEMUL1:
        alu1.alufn = 6b100010;		
        alu1.a = 16b0000000000000011;	
        alu1.b = 16b0000000000000010;	
        seg.values = {5d16,5d16,5d3,5d4};
        if(io_dip[0][0]){
          state.d = state.MANUAL;}
        counter.d = counter.q+1;
        if(io_button[3] | counter.q[TIMER]==1){
          counter.d = 0;
          state.d = state.END;}
        
      state.END:
        seg.values = {5d31,5d14,5d16,5d13};
        if(io_button[1] == 1){
           state.d = state.CASEADD;}
    }      
  }
}